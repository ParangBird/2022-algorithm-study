/*******************************************************************
Algorithm Study
Baekjoon 알고리즘 중급 1 / 3 그리디알고리즘(연습)
1783 병든 나이트
2021/07/24 이호준
# 아이디어 
1. 가로길이 중요 !!
최대한 많이 가려면 결국 1칸 오른쪽 개수가 많아야함 위아래 위아래
그런데 제약조건 4번보다 많을 경우 이동방법 1개씩 모두
※ 경우의 수를 잘 나눠야한다.
말을 움직을 수 있는 경우의 수는 4가지이고 4번 이상 이동할 시 4가지를 최소 1번씩 사용해야함
위와 아래 이동 조건은 동일하기 때문에 한가지만 생각한다.
1. N < 3 일 때
  오른쪽 2칸씩 이동하는 경우의 수들만 가능하다
2. N == 1이라면 움직을 수 없음
3. N == 2일때, 경우에 따라 다르나 최대 4개까지만.. why 위아래 2칸 이동 기능 모두 사용 불가..
4. N >= 3일 때 위아래 2칸 이동도 가능
  최대로 이동하려면 최대한 오른쪽 1개의 이동하는(위아래 2칸이동)의 횟수가 많아야한다.
  하지만 문제 조건에서 4번 이상 이동할 경우 4가지 이동 가능한 방법을 최소 1번씩 이용해야한다.
  M >= 7 인 경우 부터 해당 경우를 만족할 수 있다.

※ 케이스를 나누는 문제였는데 케이스를 나누는 기준점들을 한번씩 체크하는 습관을 가져야곘다.
*******************************************************************/
#include <iostream>
#include <string>

using namespace std;

/*
 N < 3
 오른쪽 2칸씩 밖에 안됨
*/
int main(void)
{
    int N, M;
    int visit = 1;
    cin >> N >> M;

    if (N < 3)
    {
        // 위아래 1칸, 오른쪽 2칸만 진행 가능
        // 0000 0000
        // 0000
        if (N == 1)
        {
        }
        else if (M <= 7)
        {
            // 0 1 2 3 4 5 6
            // 오른쪽 2칸씩 이동 최대 가능 개수
            if (M != 1)
                visit += ((M - 1) / 2);
        }
        else
        {
            // 더 갈 수 있어도 방문 불가
            visit = 4;
        }
        cout << visit;
        return 0;
    }

    // 방문한 칸 4개 미만 제한 x
    if (M <= 4)
    {
        // 0 1 2 3
        // 0 0 0 0
        // 0 0 0 0
        visit += M - 1;
        // check
    }
    else if (M < 7)
    {
        // 3 * 5
        // 0 0 0 0 0
        // 0 0 0 0 0
        // 0 0 0 0 0
        // 1 + 2 + 2 + 1 = 6
        visit = 4;
    }
    else
    {
        /*	3 * 7 == 5
			0 0 0 0 0 0 0
			0 0 0 0 0 0 0
			0 0 0 0 0 0 0
		*/
        //  5 +
        //  0 1 3 5 6
        //  7 ~ 49 = 43
        visit += 4; // 이동횟수 4번 사용
        // M의 인덱스 6
        visit += (M - 1 - 7 + 1);
    }
    cout << visit;
    return 0;
}
// 199 8
/*
 N * M
start : (n-1, 0)

2 4
00x0
x000
20 4
0000
000x
0x00
00x0
x000


43
 */