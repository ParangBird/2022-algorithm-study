#include <iostream>
#include <algorithm>
using namespace std;

/*

2021.08.01 서혜민

n으로 입력받을 수 있는 가장 큰 수가 10^6이므로 인덱스가 10^6까지 있는 크기 10^6+1의 배열을 선언하였다.
그리고 이 배열에는 해당 수를 인덱스로서 이 수가 1까지 얼마만큼의 횟수가 걸리는 지 저장이 된다.
먼저, arr[1]은 0으로 초기화를 한 뒤,
for문을 통해 2부터 입력받은 n까지 먼저 첫번째 방법인 i가 3으로 떨어지면 i는 i를 3으로 나눈 값의 인덱스의 +1을 값을 가질 수 있고,
두번째 방법을 통해 i/2의 값의 +1을 한 값을 가질 수 있으며
마지막 방법을 통해 그전 인덱스의 +1을 한 값을 가질 수 있다.

하지만 최소값이 저장이 되야하므로, 먼저 가장 큰 수인 3으로 나눠떨어졌을 때 arr[i]는 
이전 값에 1을 더한 arr[i-1]+1과 3으로 나눈 인덱스의 값에 1을 더한 arr[i/3]+1 중 더 작은 값을 가지게 된다.
하지만 i는 2로도 나눠떨어질 수 있으므로, 이전에 저장된 값과 2로 나눈 인덱스의 값에 1을 더한 값 중 더 작은 값을 가지게 된다.
만약 2와 3으로도 나눠떨어지지 않으면 이전 인덱스의 1을 더한 값을 가지게 된다.

*/

int arr[1000001] = { 0, };
int main() {
	int n;
	cin >> n;
	arr[1] = 0;

	for (int i = 2;i <= n;i++) {
		if (i % 3 == 0) {
			arr[i] = min(arr[i - 1] + 1, arr[i / 3] + 1);
			if (i % 2 == 0) {
				arr[i]= min(arr[i], arr[i / 2] + 1 );
			}
		}
		else if (i % 2 == 0) {
			arr[i] = min(arr[i - 1] + 1, arr[i / 2] + 1);
		}
		else arr[i] = arr[i - 1] + 1;
	}
	cout << arr[n] << endl;
}